{"ast":null,"code":"/** @license | xtypejs v0.7.1 | (c) 2015, Lucas Ononiwu | MIT license, xtype.js.org/license.txt\n */\n\n/**\n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n(function (root, undefined) {\n  'use strict';\n\n  /*\n  * --------------\n  * MODULE GLOBALS\n  * --------------\n  */\n  var LIB_NAME = 'xtype',\n    LIB_VERSION = '0.7.1',\n    TYPE_DELIMITER_DEFAULT_PATTERN = '[|, ]',\n    NAME_SCHEME_DEFAULT_OPTION_VALUE = 'default',\n    OBJECT_CLASS_REGEX = /^\\[object\\s(.*)\\]$/,\n    MAX_REQUEST_TYPE_CACHE_SIZE = 250,\n    /* --- Extensions and Module Refresh --- */\n\n    registeredExtensions = [],\n    /* --- Localized function references --- */\n\n    Array = [].constructor || Array,\n    isArray = Array.isArray,\n    arrayPush = Array.prototype.push,\n    arraySlice = Array.prototype.slice,\n    Object = {}.constructor || Object,\n    objCreate = Object.create,\n    objKeys = Object.keys,\n    objToString = Object.prototype.toString,\n    newObj = function () {\n      return objCreate(null);\n    },\n    /*\n    * -----------\n    * BASE TYPES \n    * -----------\n    */\n\n    NONE_TYPE = 0,\n    // No type\n\n    /*  Nothing types  */\n\n    NULL = 1 << 0,\n    UNDEFINED = 1 << 1,\n    NAN = 1 << 2,\n    /* Boolean */\n\n    TRUE = 1 << 3,\n    FALSE = 1 << 4,\n    /*  String  */\n\n    EMPTY_STRING = 1 << 5,\n    // String with zero characters.\n    WHITESPACE = 1 << 6,\n    // String with one or more of only whitespace characters.\n    SINGLE_CHAR_STRING = 1 << 7,\n    // String with exactly one non-whitespace and zero or more whitespace characters.\n    MULTI_CHAR_STRING = 1 << 8,\n    // String with more than one non-whitespace and zero or more whitespace characters.\n\n    /* Number */\n\n    ZERO = 1 << 9,\n    POSITIVE_INTEGER = 1 << 10,\n    POSITIVE_FLOAT = 1 << 11,\n    POSITIVE_INFINITY = 1 << 12,\n    NEGATIVE_INTEGER = 1 << 13,\n    NEGATIVE_FLOAT = 1 << 14,\n    NEGATIVE_INFINITY = 1 << 15,\n    /* Array */\n\n    EMPTY_ARRAY = 1 << 16,\n    SINGLE_ELEM_ARRAY = 1 << 17,\n    MULTI_ELEM_ARRAY = 1 << 18,\n    /* Object */\n\n    EMPTY_OBJECT = 1 << 19,\n    SINGLE_PROP_OBJECT = 1 << 20,\n    MULTI_PROP_OBJECT = 1 << 21,\n    /*  ECMA types  */\n\n    SYMBOL = 1 << 22,\n    FUNCTION = 1 << 23,\n    DATE = 1 << 24,\n    ERROR = 1 << 25,\n    REGEXP = 1 << 26,\n    /*\n    * --------------\n    * DERIVED TYPES \n    * --------------\n    */\n\n    /*  Derived Simple types  */\n\n    BOOLEAN = TRUE | FALSE,\n    STRING = EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n    NUMBER = POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | ZERO,\n    ARRAY = EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY,\n    OBJECT = EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n    /*  Other derived types  */\n\n    BLANK_STRING = EMPTY_STRING | WHITESPACE,\n    NON_EMPTY_STRING = WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n    NON_BLANK_STRING = SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n    FLOAT = POSITIVE_FLOAT | NEGATIVE_FLOAT,\n    INTEGER = POSITIVE_INTEGER | NEGATIVE_INTEGER | ZERO,\n    INFINITE_NUMBER = POSITIVE_INFINITY | NEGATIVE_INFINITY,\n    NON_INFINITE_NUMBER = INTEGER | FLOAT,\n    POSITIVE_NUMBER = POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY,\n    NEGATIVE_NUMBER = NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY,\n    NON_ZERO_NUMBER = POSITIVE_NUMBER | NEGATIVE_NUMBER,\n    NON_NEGATIVE_NUMBER = POSITIVE_NUMBER | ZERO,\n    NON_POSITIVE_NUMBER = NEGATIVE_NUMBER | ZERO,\n    NON_EMPTY_OBJECT = SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n    NON_EMPTY_ARRAY = SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY,\n    NOTHING = NULL | UNDEFINED,\n    PRIMITIVE = STRING | NUMBER | BOOLEAN | SYMBOL,\n    // Composite of all base types (effectively all derived and non-derived types)\n    ANY_TYPE = NULL | UNDEFINED | NAN | SYMBOL | FUNCTION | DATE | ERROR | REGEXP | TRUE | FALSE | EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING | ZERO | POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY | EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n    // Composite of all derived types (Internal)\n    DERIVED_TYPE = BOOLEAN | STRING | NUMBER | ARRAY | OBJECT;\n  var TYPE_VALUE_MAPPING = {\n    // -- Absent --\n    'null': NULL,\n    'undefined': UNDEFINED,\n    nan: NAN,\n    // -- Boolean --\n    boolean: BOOLEAN,\n    'true': TRUE,\n    'false': FALSE,\n    // -- String --\n    string: STRING,\n    empty_string: EMPTY_STRING,\n    whitespace: WHITESPACE,\n    single_char_string: SINGLE_CHAR_STRING,\n    multi_char_string: MULTI_CHAR_STRING,\n    // Composite\n    blank_string: BLANK_STRING,\n    non_empty_string: NON_EMPTY_STRING,\n    non_blank_string: NON_BLANK_STRING,\n    // -- Number --\n    number: NUMBER,\n    zero: ZERO,\n    positive_integer: POSITIVE_INTEGER,\n    positive_float: POSITIVE_FLOAT,\n    positive_infinity: POSITIVE_INFINITY,\n    negative_integer: NEGATIVE_INTEGER,\n    negative_float: NEGATIVE_FLOAT,\n    negative_infinity: NEGATIVE_INFINITY,\n    // Composite\n    integer: INTEGER,\n    float: FLOAT,\n    infinite_number: INFINITE_NUMBER,\n    positive_number: POSITIVE_NUMBER,\n    negative_number: NEGATIVE_NUMBER,\n    non_infinite_number: NON_INFINITE_NUMBER,\n    non_positive_number: NON_POSITIVE_NUMBER,\n    non_negative_number: NON_NEGATIVE_NUMBER,\n    non_zero_number: NON_ZERO_NUMBER,\n    // -- Array --\n    array: ARRAY,\n    empty_array: EMPTY_ARRAY,\n    single_elem_array: SINGLE_ELEM_ARRAY,\n    multi_elem_array: MULTI_ELEM_ARRAY,\n    non_empty_array: NON_EMPTY_ARRAY,\n    // -- Object --\n    object: OBJECT,\n    empty_object: EMPTY_OBJECT,\n    single_prop_object: SINGLE_PROP_OBJECT,\n    multi_prop_object: MULTI_PROP_OBJECT,\n    non_empty_object: NON_EMPTY_OBJECT,\n    // -- Other --\n    symbol: SYMBOL,\n    date: DATE,\n    error: ERROR,\n    regexp: REGEXP,\n    'function': FUNCTION,\n    nothing: NOTHING,\n    primitive: PRIMITIVE,\n    any: ANY_TYPE,\n    none: NONE_TYPE\n  };\n\n  /* Custome Typeof */\n\n  var TYPEOF_NULL = 'null',\n    TYPEOF_NAN = 'nan';\n\n  /*\n  * --------------\n  * MODULE FACTORY\n  * --------------\n  */\n\n  function newModuleInstance() {\n    var moduleRefreshHandlers = [],\n      nameSchemes = newObj(),\n      activeNameScheme,\n      isAliasMode = false,\n      typeDelimiterRegExp,\n      /* Type list string memoization cache */\n      typeListStringToTypeIdCache = newObj(),\n      typeListStringToTypeIdCacheSize = 0,\n      /* Various mappings */\n      typeToValueMapping = newObj(),\n      aliasToTypeMapping = newObj(),\n      typeToAliasMapping = newObj(),\n      nameToAliasMapping = newObj(),\n      objToStringToNameMapping = newObj(),\n      optionsModule = newObj(),\n      extensionsModule = newObj();\n\n    /*\n     * ----------------\n     * MODULE FUNCTIONS\n     * ---------------- \n     */\n\n    function typeOf(item) {\n      var typeName = typeof item === 'object' || typeof item === 'function' ? objToStringToNameMapping[objToString.call(item)] || objToString.call(item).match(OBJECT_CLASS_REGEX)[1].toLowerCase() : typeof item;\n      if (typeName === 'number' && isNaN(item)) {\n        typeName = TYPEOF_NAN;\n      }\n      return isAliasMode ? nameToAliasMapping[typeName] || typeName : typeName;\n    }\n    function type(item) {\n      var typeName = item === null ? TYPEOF_NULL : typeof item === 'object' || typeof item === 'function' ? objToStringToNameMapping[objToString.call(item)] || 'object' : typeof item;\n      if (typeName === 'number' && isNaN(item)) {\n        typeName = TYPEOF_NAN;\n      }\n      return isAliasMode ? nameToAliasMapping[typeName] || typeName : typeName;\n    }\n\n    /**\n     * Checks whether the specified item is of any of the specified types.\n     */\n    function isType(item, types) {\n      var compositeType = typeof types === 'number' ? ANY_TYPE & types : typeof types === 'string' && typeListStringToTypeIdCache[types] !== undefined ? typeListStringToTypeIdCache[types] : getCompositeType(types, item);\n      return typeof compositeType === 'function' ||\n      // Item is a specified instance type\n      typeof compositeType === 'object' ||\n      // Item is a specified custom type\n      !!getBaseType(item, compositeType);\n    }\n\n    /**\n     * Return the first of the types, if any, matches the type of the item.\n     */\n    function which(item, types) {\n      types = typeof types === 'string' ? types.split(typeDelimiterRegExp) : !isArray(types) ? [types] : types;\n      var typeCount = types.length,\n        typeIndex;\n      for (typeIndex = 0; typeIndex < typeCount; typeIndex++) {\n        if (isType(item, types[typeIndex])) {\n          return types[typeIndex];\n        }\n      }\n      return typeToAliasMapping[NONE_TYPE];\n    }\n\n    /**\n     * Returns the most specific available type for the specified item. \n     */\n    function xtype(item) {\n      return typeToAliasMapping[getBaseType(item)];\n    }\n\n    /**\n     * Gets the derived type of the specified item.\n     * @param eligibleTypesComposite The derived type \n     * composite whose member types filter the result.\n     */\n    function getBaseType(item, eligibleTypesComposite) {\n      var itemSimpleType = aliasToTypeMapping[type(item)] || NONE_TYPE;\n      if ((itemSimpleType & DERIVED_TYPE) === 0) {\n        // Not a derived type, so return eligible type immediately\n        return itemSimpleType & (eligibleTypesComposite !== undefined ? ANY_TYPE & eligibleTypesComposite : ANY_TYPE);\n      }\n      var derivedTypeComposite = eligibleTypesComposite !== undefined ? DERIVED_TYPE & eligibleTypesComposite : DERIVED_TYPE;\n      if (derivedTypeComposite === 0) {\n        // No matching eligible derived type\n        return 0;\n      }\n      var strLength,\n        // strings\n        strTrimLength, arrElemCount,\n        // arrays\n        objPropCount; // objects\n\n      // Determine base type from derived type\n      switch (itemSimpleType) {\n        case STRING:\n          return (strLength = item.length) && (strTrimLength = item.trim().length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_STRING & derivedTypeComposite && strLength === 0 ? EMPTY_STRING : WHITESPACE & derivedTypeComposite && strLength > 0 && strTrimLength === 0 ? WHITESPACE : MULTI_CHAR_STRING & derivedTypeComposite && strTrimLength > 1 ? MULTI_CHAR_STRING : SINGLE_CHAR_STRING & derivedTypeComposite && strTrimLength === 1 ? SINGLE_CHAR_STRING : 0;\n        case NUMBER:\n          // Use non-strict equality to handle primitive and boxed zero number\n          return ZERO & derivedTypeComposite && item == 0 ? ZERO // jshint ignore:line                        \n          : NON_INFINITE_NUMBER & derivedTypeComposite && isFinite(item) ? INTEGER & derivedTypeComposite && item % 1 === 0 ? POSITIVE_INTEGER & derivedTypeComposite && item > 0 ? POSITIVE_INTEGER : NEGATIVE_INTEGER & derivedTypeComposite && item < 0 ? NEGATIVE_INTEGER : 0 : FLOAT & derivedTypeComposite && item % 1 !== 0 ? POSITIVE_FLOAT & derivedTypeComposite && item > 0 ? POSITIVE_FLOAT : NEGATIVE_FLOAT & derivedTypeComposite && item < 0 ? NEGATIVE_FLOAT : 0 : 0 : INFINITE_NUMBER & derivedTypeComposite && !isFinite(item) ? POSITIVE_INFINITY & derivedTypeComposite && item > 0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY & derivedTypeComposite && item < 0 ? NEGATIVE_INFINITY : 0 : 0;\n        case BOOLEAN:\n          // Use non-strict equality to handle primitive and boxed booleans\n          return TRUE & derivedTypeComposite && item == true ? TRUE // jshint ignore:line\n          : FALSE & derivedTypeComposite && item == false ? FALSE // jshint ignore:line\n          : 0;\n        case ARRAY:\n          return (arrElemCount = item.length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_ARRAY & derivedTypeComposite && arrElemCount === 0 ? EMPTY_ARRAY : SINGLE_ELEM_ARRAY & derivedTypeComposite && arrElemCount === 1 ? SINGLE_ELEM_ARRAY : MULTI_ELEM_ARRAY & derivedTypeComposite && arrElemCount > 1 ? MULTI_ELEM_ARRAY : 0;\n        case OBJECT:\n          return (objPropCount = objKeys(item).length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_OBJECT & derivedTypeComposite && objPropCount === 0 ? EMPTY_OBJECT : SINGLE_PROP_OBJECT & derivedTypeComposite && objPropCount === 1 ? SINGLE_PROP_OBJECT : MULTI_PROP_OBJECT & derivedTypeComposite && objPropCount > 1 ? MULTI_PROP_OBJECT : 0;\n      }\n      return 0;\n    }\n\n    /**\n     * Gets the composite type consisting of the specified types.\n     */\n    function getCompositeType(types, item) {\n      var typeString;\n      if (typeof types === 'string') {\n        // uncached string\n        typeString = types;\n        types = types.split(typeDelimiterRegExp);\n      } else if (!isArray(types)) {\n        types = [types];\n      }\n      var compositeType = 0,\n        requestedType,\n        typeDefinition;\n      for (var typeIndex = 0, typeCount = types.length; typeIndex < typeCount; typeIndex++) {\n        requestedType = types[typeIndex];\n        typeDefinition = typeof requestedType === 'string' ? aliasToTypeMapping[requestedType] || 0 : typeof requestedType === 'object' ?\n        // Support for unregistered custom-validated type if validator function field present in obj\n        requestedType !== null && typeof requestedType.validator === 'function' ? requestedType : 0 : requestedType || 0;\n        if (typeof typeDefinition === 'number') {\n          compositeType = compositeType | ANY_TYPE & typeDefinition;\n        } else if (typeof typeDefinition === 'function' && item instanceof typeDefinition) {\n          return typeDefinition;\n        } else if (typeof typeDefinition === 'object' && typeDefinition.validator(item) === true) {\n          // No further need to null-check type definition\n          return typeDefinition;\n        }\n      }\n      if (compositeType && typeString && typeListStringToTypeIdCacheSize <= MAX_REQUEST_TYPE_CACHE_SIZE) {\n        typeListStringToTypeIdCache[typeString] = compositeType;\n        typeListStringToTypeIdCacheSize++;\n      }\n      return compositeType;\n    }\n\n    /*\n     * ----------------\n     * HELPER FUNCTIONS\n     * ----------------\n     */\n\n    /**\n     * Builds an alias map using data in supplied value and alias mappings.\n     */\n    function buildAliasMappings() {\n      var typeAliasMapping = newObj(),\n        aliasTypeMapping = newObj(),\n        nameAliasMapping = newObj(),\n        usedAliases = newObj();\n      objKeys(typeToValueMapping).forEach(function (typeName) {\n        var typeValue = typeToValueMapping[typeName];\n        var aliasName = activeNameScheme ? activeNameScheme[typeName] : typeName;\n        aliasName = typeof aliasName === 'string' && aliasName.length > 0 ? aliasName : typeName;\n        if (aliasName in usedAliases) {\n          throwError('Type name conflict: \"' + aliasName + '\" is aliased to \"' + typeName + '\" and \"' + usedAliases[aliasName] + '\"');\n        }\n        if (typeof typeValue === 'number') {\n          typeAliasMapping[typeValue] = aliasName; // Type Ids used only for built-in simple and extended types (with numeric Ids) \n        }\n\n        aliasTypeMapping[aliasName] = typeValue;\n        nameAliasMapping[typeName] = aliasName;\n        usedAliases[aliasName] = typeName;\n      });\n      typeToAliasMapping = typeAliasMapping;\n      aliasToTypeMapping = aliasTypeMapping;\n      nameToAliasMapping = nameAliasMapping;\n      isAliasMode = !!activeNameScheme;\n      clearTypeListStringCache();\n    }\n    function defineInterfacePackagesAndMethods(hostObj) {\n      hostObj.not = newObj();\n      hostObj.any = newObj();\n      hostObj.all = newObj();\n      hostObj.some = newObj();\n      hostObj.none = newObj();\n      hostObj.not.is = function (value, types) {\n        return !isType(value, types);\n      };\n      hostObj.any.is = getInterfaceFunction(isType, true, true, undefined, true);\n      hostObj.all.is = getInterfaceFunction(isType, true, undefined, true, false);\n      hostObj.some.is = getInterfaceFunction(isType, true, true, true, true);\n      hostObj.none.is = getInterfaceFunction(isType, true, true, undefined, false);\n    }\n\n    /**\n     * Defines the typeId property and associated type check\n     * and interface methods for the specified type.\n     */\n    function defineType(typeName, typeDefinition, hostObj) {\n      if (typeName in typeToValueMapping) {\n        throwError('Cannot define type \\'' + typeName + '\\' - type already defined');\n      }\n      typeToValueMapping[typeName] = typeDefinition;\n      if (typeof typeDefinition === 'number') {\n        Object.defineProperty(hostObj, typeName.toUpperCase(), {\n          value: typeToValueMapping[typeName],\n          enumerable: true,\n          writable: false,\n          configurable: false\n        });\n      }\n      var typeMethodName = getTypeMethodName(typeName);\n      var typeCheckFunction = function (item) {\n        return isType(item, typeToValueMapping[typeName] || typeName);\n      };\n      hostObj[typeMethodName] = typeCheckFunction;\n      hostObj.not[typeMethodName] = function (value) {\n        return !typeCheckFunction(value);\n      };\n      hostObj.any[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, true);\n      hostObj.all[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, undefined, true, false);\n      hostObj.some[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, true, true);\n      hostObj.none[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, false);\n    }\n\n    /**\n     * Clears the memoization cache of type list strings used in requests.\n     */\n    function clearTypeListStringCache() {\n      typeListStringToTypeIdCache = newObj();\n      typeListStringToTypeIdCacheSize = 0;\n    }\n\n    /**\n     * Gets the name to be used for the type-matching \n     * method name for the specified type.\n     */\n    function getTypeMethodName(typeName) {\n      var capitalizedTypeName = typeName.toLowerCase().replace(/(^|_)(.)/g, function (match, camelPrefix, camelChar) {\n        return camelChar.toUpperCase();\n      });\n      return 'is' + capitalizedTypeName;\n    }\n\n    /**\n     * Creates an interface function using the specified parameters.\n     */\n    function getInterfaceFunction(delegateFunction, withTypes, trueCondition, falseCondition, terminationResult) {\n      return function (values, types) {\n        values = !withTypes && arguments.length > 1 ? arraySlice.call(arguments) : isArray(values) ? values : [values];\n        var trueResult = false,\n          falseResult = false,\n          valueIndex;\n        for (valueIndex = 0; valueIndex < values.length; valueIndex++) {\n          if (delegateFunction(values[valueIndex], types)) {\n            trueResult = true;\n          } else {\n            falseResult = true;\n          }\n          if ((trueCondition === undefined || trueResult === trueCondition) && (falseCondition === undefined || falseResult === falseCondition)) {\n            return terminationResult;\n          }\n        }\n        return !terminationResult;\n      };\n    }\n    function capitalize(string) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n    function throwError(message) {\n      throw new Error(LIB_NAME + ': ' + message);\n    }\n\n    /*\n     * -----------------\n     * EXTENSIONS MODULE\n     * -----------------\n     */\n\n    function registerNameScheme(schemeName, schemeAliases) {\n      if (typeof schemeName !== 'string' || schemeName.trim().length === 0 || typeof schemeAliases !== 'object') {\n        return;\n      }\n      var trimSchemeName = schemeName.trim(),\n        existingScheme = nameSchemes[trimSchemeName],\n        newScheme = newObj();\n      objKeys(schemeAliases).forEach(function (typeName) {\n        newScheme[typeName] = schemeAliases[typeName];\n      });\n      nameSchemes[trimSchemeName] = newScheme;\n      return existingScheme;\n    }\n    extensionsModule.registerNameScheme = registerNameScheme;\n\n    /*\n     * --------------\n     * OPTIONS MODULE\n     * --------------\n     */\n\n    function setDelimiterPattern(delimiterPattern) {\n      delimiterPattern = delimiterPattern === null || delimiterPattern === undefined || delimiterPattern === '' ? TYPE_DELIMITER_DEFAULT_PATTERN : delimiterPattern;\n      if (typeof delimiterPattern !== 'string') {\n        return;\n      }\n      delimiterPattern = '[ ]*' + delimiterPattern + '[ ]*';\n      if (typeDelimiterRegExp && delimiterPattern === typeDelimiterRegExp.source) {\n        return;\n      }\n      typeDelimiterRegExp = new RegExp(delimiterPattern, 'g');\n      clearTypeListStringCache();\n    }\n    function setNameScheme(nameScheme) {\n      if (nameScheme === undefined || nameScheme === null || nameScheme === NAME_SCHEME_DEFAULT_OPTION_VALUE) {\n        nameScheme = null;\n      } else if (typeof nameScheme === 'string' && nameScheme in nameSchemes) {\n        nameScheme = nameSchemes[nameScheme];\n      }\n      if (nameScheme !== null && typeof nameScheme !== 'object') {\n        throwError('Unknown name scheme \"' + nameScheme + '\"');\n      }\n      activeNameScheme = nameScheme;\n      doRefresh();\n    }\n    function setOptions(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n      objKeys(options).forEach(function (optionName) {\n        var optionMethod = optionsModule['set' + capitalize(optionName)];\n        if (typeof optionMethod === 'function') {\n          optionMethod(options[optionName]);\n        }\n      });\n    }\n    optionsModule.setDelimiterPattern = setDelimiterPattern;\n    optionsModule.setNameScheme = setNameScheme;\n    optionsModule.set = setOptions;\n\n    /*\n     * --------------\n     * MODULE REFRESH\n     * --------------\n     */\n\n    function coreModuleRefreshHandler() {\n      buildAliasMappings();\n    }\n    function doRefresh() {\n      coreModuleRefreshHandler();\n      doModuleTriggeredRefresh(coreModuleRefreshHandler);\n    }\n    var doModuleTriggeredRefresh = function () {\n      var handlersRequestingModuleRefresh = [],\n        isModuleRefreshing = false,\n        isModuleRefreshRequested = false;\n      function refreshExtensions(requestingHandlers) {\n        moduleRefreshHandlers.forEach(function (handler) {\n          /*\n           * Don't invoke handlers belonging to extensions \n           * that requested the current refresh.\n           */\n          if (requestingHandlers.indexOf(handler) < 0) {\n            handler.call();\n          }\n        });\n      }\n\n      /*\n       * Handles extensions' refresh requests by bunching all refresh \n       * requests made during an active refresh into a single subsequent\n       * refresh operation performed on completion of the active refresh.\n       * Also, when the subsequent refresh is processed, excludes handlers \n       * of all the extensions which requested the refresh, in order to \n       * prevent potential cyclic refresh loops in poorly implemented \n       * extensions which may trigger new refreshes while responding to \n       * refresh requests originated by themselves.\n       */\n      return function (requestingHandler) {\n        isModuleRefreshRequested = true;\n        if (requestingHandler) {\n          handlersRequestingModuleRefresh.push(requestingHandler);\n        }\n        if (isModuleRefreshing) {\n          return;\n        }\n        isModuleRefreshing = true;\n        while (isModuleRefreshRequested) {\n          isModuleRefreshRequested = false;\n          refreshExtensions(handlersRequestingModuleRefresh);\n        }\n        handlersRequestingModuleRefresh = [];\n        isModuleRefreshing = false;\n      };\n    }();\n\n    /*\n     * ----------------\n     * ADDON EXTENSIONS\n     * ----------------\n     */\n\n    function registerExtensions(extensions, xtypeModule) {\n      (isArray(extensions) ? extensions : [extensions]).forEach(function (extension) {\n        if (!extension || extension.type !== 'xtypejs' || typeof extension.init !== 'function') {\n          throwError('Invalid extension - \"type\" property must be \"xtypejs\" and \"init\" property must be a function');\n        }\n        registeredExtensions.push(extension.init);\n        applyExtension(extension.init, xtypeModule);\n      });\n    }\n    function applyExtension(extensionInit, hostModule) {\n      var moduleRefreshHandler = null,\n        extensionInterface = {\n          getTypeDefinitions: function () {\n            return typeToValueMapping;\n          },\n          getNameSchemes: function () {\n            return nameSchemes;\n          },\n          getActiveNameScheme: function () {\n            return activeNameScheme;\n          },\n          defineType: function (typeName, typeValue) {\n            defineType(typeName, typeValue, hostModule);\n          },\n          refresh: function () {\n            doModuleTriggeredRefresh(moduleRefreshHandler);\n          },\n          setRefreshHandler: function (handler) {\n            var existingHandlerIndex = moduleRefreshHandlers.indexOf(moduleRefreshHandler || handler);\n            if (existingHandlerIndex > -1) {\n              moduleRefreshHandlers.splice(existingHandlerIndex, 1);\n            }\n            if (typeof handler === 'function') {\n              moduleRefreshHandlers.push(handler);\n              moduleRefreshHandler = handler;\n            }\n          }\n        };\n      extensionInit.call(extensionInterface, hostModule);\n    }\n\n    /*\n     * ---------------------\n     * MODULE SETUP / EXPORT\n     * ---------------------\n     */\n\n    function init() {\n      var moduleExport = xtype;\n      setDelimiterPattern(TYPE_DELIMITER_DEFAULT_PATTERN);\n      ['Boolean', 'Number', 'String', 'Symbol', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error'].forEach(function (objectType) {\n        objToStringToNameMapping['[object ' + objectType + ']'] = objectType.toLowerCase();\n      });\n      defineInterfacePackagesAndMethods(moduleExport);\n      objKeys(TYPE_VALUE_MAPPING).forEach(function (typeName) {\n        defineType(typeName, TYPE_VALUE_MAPPING[typeName], moduleExport);\n      });\n      buildAliasMappings();\n      moduleRefreshHandlers.push(coreModuleRefreshHandler);\n      Object.defineProperty(moduleExport, 'VERSION', {\n        value: /\\s*{{[^}]*}}\\s*/g.test(LIB_VERSION) ? 'unspecified' : LIB_VERSION,\n        enumerable: true,\n        writable: false,\n        configurable: false\n      });\n\n      /*\n       * Attach API methods to module export\n       */\n\n      moduleExport.type = type;\n      moduleExport.typeOf = typeOf;\n      moduleExport.which = which;\n      moduleExport.is = isType;\n      moduleExport.ext = extensionsModule;\n      moduleExport.options = optionsModule;\n      moduleExport.newInstance = newModuleInstance;\n      moduleExport.ext.registerExtension = function (extensions) {\n        extensions = arguments.length > 1 ? arraySlice.call(arguments) : extensions;\n        registerExtensions(extensions, moduleExport);\n      };\n\n      /*\n       * Apply registered extensions on new instance\n       */\n\n      registeredExtensions.forEach(function (extension) {\n        applyExtension(extension, moduleExport);\n      });\n      return moduleExport;\n    }\n    return init();\n  }\n\n  /*\n   * Export module\n   */\n  var moduleExport = newModuleInstance();\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return moduleExport;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = moduleExport;\n  } else {\n    moduleExport.noConflict = function (previouslyDefinedValue) {\n      return function () {\n        root[LIB_NAME] = previouslyDefinedValue;\n        delete moduleExport.noConflict;\n        return moduleExport;\n      };\n    }(root[LIB_NAME]);\n    root[LIB_NAME] = moduleExport;\n  }\n})(this);","map":{"version":3,"names":["root","undefined","LIB_NAME","LIB_VERSION","TYPE_DELIMITER_DEFAULT_PATTERN","NAME_SCHEME_DEFAULT_OPTION_VALUE","OBJECT_CLASS_REGEX","MAX_REQUEST_TYPE_CACHE_SIZE","registeredExtensions","Array","constructor","isArray","arrayPush","prototype","push","arraySlice","slice","Object","objCreate","create","objKeys","keys","objToString","toString","newObj","NONE_TYPE","NULL","UNDEFINED","NAN","TRUE","FALSE","EMPTY_STRING","WHITESPACE","SINGLE_CHAR_STRING","MULTI_CHAR_STRING","ZERO","POSITIVE_INTEGER","POSITIVE_FLOAT","POSITIVE_INFINITY","NEGATIVE_INTEGER","NEGATIVE_FLOAT","NEGATIVE_INFINITY","EMPTY_ARRAY","SINGLE_ELEM_ARRAY","MULTI_ELEM_ARRAY","EMPTY_OBJECT","SINGLE_PROP_OBJECT","MULTI_PROP_OBJECT","SYMBOL","FUNCTION","DATE","ERROR","REGEXP","BOOLEAN","STRING","NUMBER","ARRAY","OBJECT","BLANK_STRING","NON_EMPTY_STRING","NON_BLANK_STRING","FLOAT","INTEGER","INFINITE_NUMBER","NON_INFINITE_NUMBER","POSITIVE_NUMBER","NEGATIVE_NUMBER","NON_ZERO_NUMBER","NON_NEGATIVE_NUMBER","NON_POSITIVE_NUMBER","NON_EMPTY_OBJECT","NON_EMPTY_ARRAY","NOTHING","PRIMITIVE","ANY_TYPE","DERIVED_TYPE","TYPE_VALUE_MAPPING","nan","boolean","string","empty_string","whitespace","single_char_string","multi_char_string","blank_string","non_empty_string","non_blank_string","number","zero","positive_integer","positive_float","positive_infinity","negative_integer","negative_float","negative_infinity","integer","float","infinite_number","positive_number","negative_number","non_infinite_number","non_positive_number","non_negative_number","non_zero_number","array","empty_array","single_elem_array","multi_elem_array","non_empty_array","object","empty_object","single_prop_object","multi_prop_object","non_empty_object","symbol","date","error","regexp","nothing","primitive","any","none","TYPEOF_NULL","TYPEOF_NAN","newModuleInstance","moduleRefreshHandlers","nameSchemes","activeNameScheme","isAliasMode","typeDelimiterRegExp","typeListStringToTypeIdCache","typeListStringToTypeIdCacheSize","typeToValueMapping","aliasToTypeMapping","typeToAliasMapping","nameToAliasMapping","objToStringToNameMapping","optionsModule","extensionsModule","typeOf","item","typeName","call","match","toLowerCase","isNaN","type","isType","types","compositeType","getCompositeType","getBaseType","which","split","typeCount","length","typeIndex","xtype","eligibleTypesComposite","itemSimpleType","derivedTypeComposite","strLength","strTrimLength","arrElemCount","objPropCount","trim","isFinite","typeString","requestedType","typeDefinition","validator","buildAliasMappings","typeAliasMapping","aliasTypeMapping","nameAliasMapping","usedAliases","forEach","typeValue","aliasName","throwError","clearTypeListStringCache","defineInterfacePackagesAndMethods","hostObj","not","all","some","is","value","getInterfaceFunction","defineType","defineProperty","toUpperCase","enumerable","writable","configurable","typeMethodName","getTypeMethodName","typeCheckFunction","capitalizedTypeName","replace","camelPrefix","camelChar","delegateFunction","withTypes","trueCondition","falseCondition","terminationResult","values","arguments","trueResult","falseResult","valueIndex","capitalize","charAt","message","Error","registerNameScheme","schemeName","schemeAliases","trimSchemeName","existingScheme","newScheme","setDelimiterPattern","delimiterPattern","source","RegExp","setNameScheme","nameScheme","doRefresh","setOptions","options","optionName","optionMethod","set","coreModuleRefreshHandler","doModuleTriggeredRefresh","handlersRequestingModuleRefresh","isModuleRefreshing","isModuleRefreshRequested","refreshExtensions","requestingHandlers","handler","indexOf","requestingHandler","registerExtensions","extensions","xtypeModule","extension","init","applyExtension","extensionInit","hostModule","moduleRefreshHandler","extensionInterface","getTypeDefinitions","getNameSchemes","getActiveNameScheme","refresh","setRefreshHandler","existingHandlerIndex","splice","moduleExport","objectType","test","ext","newInstance","registerExtension","define","amd","module","exports","noConflict","previouslyDefinedValue"],"sources":["F:/dev/alex/node_modules/xtypejs/dist/xtype.js"],"sourcesContent":["/** @license | xtypejs v0.7.1 | (c) 2015, Lucas Ononiwu | MIT license, xtype.js.org/license.txt\n */\n\n/**\n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n \n(function(root, undefined) {\n    \n    'use strict';\n\n    /*\n    * --------------\n    * MODULE GLOBALS\n    * --------------\n    */\n    \n    var LIB_NAME = 'xtype',\n        LIB_VERSION = '0.7.1',\n        \n        TYPE_DELIMITER_DEFAULT_PATTERN = '[|, ]',\n        NAME_SCHEME_DEFAULT_OPTION_VALUE = 'default',\n        OBJECT_CLASS_REGEX = /^\\[object\\s(.*)\\]$/,\n        MAX_REQUEST_TYPE_CACHE_SIZE = 250,\n        \n        /* --- Extensions and Module Refresh --- */\n\n        registeredExtensions = [],\n        \n        /* --- Localized function references --- */\n\n        Array = ([]).constructor || Array,\n        isArray = Array.isArray,\n        arrayPush = Array.prototype.push,\n        arraySlice = Array.prototype.slice,\n        \n        Object = ({}).constructor || Object,\n        objCreate = Object.create,\n        objKeys = Object.keys,\n        objToString = Object.prototype.toString,\n\n        newObj = function() {\n            return objCreate(null);\n        },\n        \n        /*\n        * -----------\n        * BASE TYPES \n        * -----------\n        */\n        \n        NONE_TYPE           = 0,                // No type\n        \n        /*  Nothing types  */\n        \n        NULL                = (1 << 0),\n        UNDEFINED           = (1 << 1),\n        NAN                 = (1 << 2),\n        \n        /* Boolean */\n        \n        TRUE                = (1 << 3),\n        FALSE               = (1 << 4),\n        \n        /*  String  */\n        \n        EMPTY_STRING        = (1 << 5),        // String with zero characters.\n        WHITESPACE          = (1 << 6),        // String with one or more of only whitespace characters.\n        SINGLE_CHAR_STRING  = (1 << 7),        // String with exactly one non-whitespace and zero or more whitespace characters.\n        MULTI_CHAR_STRING   = (1 << 8),        // String with more than one non-whitespace and zero or more whitespace characters.\n        \n        /* Number */\n        \n        ZERO                = (1 << 9),\n        POSITIVE_INTEGER    = (1 << 10), \n        POSITIVE_FLOAT      = (1 << 11), \n        POSITIVE_INFINITY   = (1 << 12), \n        NEGATIVE_INTEGER    = (1 << 13),\n        NEGATIVE_FLOAT      = (1 << 14),\n        NEGATIVE_INFINITY   = (1 << 15),\n        \n        /* Array */\n        \n        EMPTY_ARRAY         = (1 << 16),\n        SINGLE_ELEM_ARRAY   = (1 << 17), \n        MULTI_ELEM_ARRAY    = (1 << 18),\n        \n        /* Object */\n        \n        EMPTY_OBJECT        = (1 << 19),\n        SINGLE_PROP_OBJECT  = (1 << 20),\n        MULTI_PROP_OBJECT   = (1 << 21),\n        \n        /*  ECMA types  */\n        \n        SYMBOL              = (1 << 22),\n        FUNCTION            = (1 << 23), \n        DATE                = (1 << 24), \n        ERROR               = (1 << 25), \n        REGEXP              = (1 << 26),\n        \n        /*\n        * --------------\n        * DERIVED TYPES \n        * --------------\n        */\n        \n        /*  Derived Simple types  */\n        \n        BOOLEAN             = (TRUE | FALSE), \n        STRING              = (EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING), \n        NUMBER              = (POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | ZERO),\n        ARRAY               = (EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY),\n        OBJECT              = (EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        \n        /*  Other derived types  */\n        \n        BLANK_STRING        = (EMPTY_STRING | WHITESPACE),\n        NON_EMPTY_STRING    = (WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING),\n        NON_BLANK_STRING    = (SINGLE_CHAR_STRING | MULTI_CHAR_STRING),\n        \n        FLOAT               = (POSITIVE_FLOAT | NEGATIVE_FLOAT),\n        INTEGER             = (POSITIVE_INTEGER | NEGATIVE_INTEGER | ZERO),\n        INFINITE_NUMBER     = (POSITIVE_INFINITY | NEGATIVE_INFINITY),\n        NON_INFINITE_NUMBER = (INTEGER | FLOAT),\n        POSITIVE_NUMBER     = (POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY),\n        NEGATIVE_NUMBER     = (NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY),\n        NON_ZERO_NUMBER     = (POSITIVE_NUMBER | NEGATIVE_NUMBER),\n        NON_NEGATIVE_NUMBER = (POSITIVE_NUMBER | ZERO),\n        NON_POSITIVE_NUMBER = (NEGATIVE_NUMBER | ZERO),\n        \n        NON_EMPTY_OBJECT    = (SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        NON_EMPTY_ARRAY     = (SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY),\n        \n        NOTHING             = (NULL | UNDEFINED),\n        PRIMITIVE           = (STRING | NUMBER | BOOLEAN | SYMBOL),\n        \n        // Composite of all base types (effectively all derived and non-derived types)\n        ANY_TYPE = (\n                NULL | UNDEFINED | NAN |\n                SYMBOL | FUNCTION | DATE | ERROR | REGEXP |\n                TRUE | FALSE |\n                EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING |\n                ZERO | POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY |\n                EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY | \n                EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        \n        // Composite of all derived types (Internal)\n        DERIVED_TYPE = (BOOLEAN | STRING | NUMBER | ARRAY | OBJECT);\n    \n    var TYPE_VALUE_MAPPING = {\n            \n            // -- Absent --\n            'null': NULL,\n            'undefined': UNDEFINED,\n            nan: NAN,\n            \n            // -- Boolean --\n            boolean: BOOLEAN, \n            'true': TRUE,\n            'false': FALSE,\n            \n            // -- String --\n            string: STRING, \n            empty_string: EMPTY_STRING,\n            whitespace: WHITESPACE,\n            single_char_string: SINGLE_CHAR_STRING,\n            multi_char_string: MULTI_CHAR_STRING,\n            // Composite\n            blank_string: BLANK_STRING,\n            non_empty_string: NON_EMPTY_STRING,\n            non_blank_string: NON_BLANK_STRING,\n            \n            // -- Number --\n            number: NUMBER,\n            zero: ZERO,\n            positive_integer: POSITIVE_INTEGER, \n            positive_float: POSITIVE_FLOAT, \n            positive_infinity: POSITIVE_INFINITY, \n            negative_integer: NEGATIVE_INTEGER,\n            negative_float: NEGATIVE_FLOAT,\n            negative_infinity: NEGATIVE_INFINITY, \n            // Composite\n            integer: INTEGER,\n            float: FLOAT,\n            infinite_number: INFINITE_NUMBER,\n            positive_number: POSITIVE_NUMBER, \n            negative_number: NEGATIVE_NUMBER,\n            non_infinite_number: NON_INFINITE_NUMBER,\n            non_positive_number: NON_POSITIVE_NUMBER,\n            non_negative_number: NON_NEGATIVE_NUMBER,\n            non_zero_number: NON_ZERO_NUMBER,\n            \n            // -- Array --\n            array: ARRAY, \n            empty_array: EMPTY_ARRAY, \n            single_elem_array: SINGLE_ELEM_ARRAY,\n            multi_elem_array: MULTI_ELEM_ARRAY,\n            non_empty_array: NON_EMPTY_ARRAY,\n            \n            // -- Object --\n            object: OBJECT,\n            empty_object: EMPTY_OBJECT,\n            single_prop_object: SINGLE_PROP_OBJECT,\n            multi_prop_object: MULTI_PROP_OBJECT,\n            non_empty_object: NON_EMPTY_OBJECT,\n            \n            // -- Other --\n            symbol: SYMBOL,\n            date: DATE, \n            error: ERROR, \n            regexp: REGEXP,             \n            'function': FUNCTION, \n            \n            nothing: NOTHING,            \n            primitive: PRIMITIVE,\n            any: ANY_TYPE,\n            none: NONE_TYPE\n    };\n\n    /* Custome Typeof */\n    \n    var TYPEOF_NULL = 'null',\n        TYPEOF_NAN = 'nan';\n\n\n    /*\n    * --------------\n    * MODULE FACTORY\n    * --------------\n    */\n    \n    function newModuleInstance() {\n        \n        var moduleRefreshHandlers = [],\n            nameSchemes = newObj(),\n            activeNameScheme,\n            isAliasMode = false,\n            typeDelimiterRegExp,\n            \n            /* Type list string memoization cache */\n            typeListStringToTypeIdCache = newObj(),\n            typeListStringToTypeIdCacheSize = 0,\n            \n            /* Various mappings */\n            typeToValueMapping = newObj(),\n            aliasToTypeMapping = newObj(),\n            typeToAliasMapping = newObj(),\n            nameToAliasMapping = newObj(),\n            objToStringToNameMapping = newObj(),\n        \n            optionsModule = newObj(),\n            extensionsModule = newObj();\n        \n        /*\n         * ----------------\n         * MODULE FUNCTIONS\n         * ---------------- \n         */\n        \n        function typeOf(item) {\n            var typeName = (typeof item === 'object' || typeof item === 'function') ?  \n                            (objToStringToNameMapping[objToString.call(item)] || \n                            objToString.call(item).match(OBJECT_CLASS_REGEX)[1].toLowerCase())\n                    : typeof item;\n            \n            if (typeName === 'number' && isNaN(item)) {\n                typeName = TYPEOF_NAN;\n            }\n            \n            return (isAliasMode ? (nameToAliasMapping[typeName] || typeName) : typeName);\n        }\n        \n        function type(item) {\n            var typeName = (item === null) ? TYPEOF_NULL\n                    : (typeof item === 'object' || typeof item === 'function') ?\n                            (objToStringToNameMapping[objToString.call(item)] || 'object')\n                    : typeof item;\n            \n            if (typeName === 'number' && isNaN(item)) {\n                typeName = TYPEOF_NAN;\n            }\n            \n            return (isAliasMode ? (nameToAliasMapping[typeName] || typeName) : typeName);\n        }\n        \n        /**\n         * Checks whether the specified item is of any of the specified types.\n         */\n        function isType(item, types) {\n            var compositeType = (typeof types === 'number') ? (ANY_TYPE & types)\n                    : (typeof types === 'string' && typeListStringToTypeIdCache[types] !== undefined) ?\n                            typeListStringToTypeIdCache[types]\n                    : getCompositeType(types, item);\n            \n            return (typeof compositeType === 'function') ||     // Item is a specified instance type\n                    (typeof compositeType === 'object') ||      // Item is a specified custom type\n                    !!(getBaseType(item, compositeType));\n        }\n    \n        /**\n         * Return the first of the types, if any, matches the type of the item.\n         */\n        function which(item, types) {\n            types = (typeof types === 'string') ? types.split(typeDelimiterRegExp)\n                    : (!isArray(types) ? [types]\n                    : types);\n            \n            var typeCount = types.length,\n                typeIndex;\n            \n            for (typeIndex = 0; typeIndex < typeCount; typeIndex++) {\n                if (isType(item, types[typeIndex])) {\n                    return types[typeIndex];\n                }\n            }\n            return typeToAliasMapping[NONE_TYPE];\n        }\n        \n        /**\n         * Returns the most specific available type for the specified item. \n         */\n        function xtype(item) {\n            return typeToAliasMapping[getBaseType(item)];\n        }\n    \n        /**\n         * Gets the derived type of the specified item.\n         * @param eligibleTypesComposite The derived type \n         * composite whose member types filter the result.\n         */\n        function getBaseType(item, eligibleTypesComposite) {\n            var itemSimpleType = (aliasToTypeMapping[type(item)] || NONE_TYPE);\n            \n            if ((itemSimpleType & DERIVED_TYPE) === 0) {\n                // Not a derived type, so return eligible type immediately\n                return (itemSimpleType & (eligibleTypesComposite !== undefined ? \n                        (ANY_TYPE & eligibleTypesComposite) : ANY_TYPE));\n            }\n            \n            var derivedTypeComposite = (eligibleTypesComposite !== undefined ? \n                    (DERIVED_TYPE & eligibleTypesComposite) : DERIVED_TYPE);\n            \n            if (derivedTypeComposite === 0) {\n                // No matching eligible derived type\n                return 0;\n            }\n            \n            var strLength,          // strings\n                strTrimLength,\n                arrElemCount,       // arrays\n                objPropCount;       // objects\n            \n            // Determine base type from derived type\n            switch (itemSimpleType) {\n                \n                case STRING: \n                    return ((strLength = item.length) && (strTrimLength = item.trim().length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_STRING & derivedTypeComposite) && strLength === 0) ? EMPTY_STRING\n                        : ((WHITESPACE & derivedTypeComposite) && strLength > 0 && strTrimLength === 0) ? WHITESPACE\n                        : ((MULTI_CHAR_STRING & derivedTypeComposite) && strTrimLength > 1) ? MULTI_CHAR_STRING\n                        : ((SINGLE_CHAR_STRING & derivedTypeComposite) && strTrimLength === 1) ? SINGLE_CHAR_STRING\n                        : 0;\n                \n                case NUMBER:\n                        // Use non-strict equality to handle primitive and boxed zero number\n                    return ((ZERO & derivedTypeComposite) && item == 0) ? ZERO                  // jshint ignore:line                        \n                        : ((NON_INFINITE_NUMBER & derivedTypeComposite) && isFinite(item)) ? (\n                                ((INTEGER & derivedTypeComposite) && (item % 1) === 0) ? (\n                                        ((POSITIVE_INTEGER & derivedTypeComposite) && item > 0) ? POSITIVE_INTEGER\n                                        : ((NEGATIVE_INTEGER & derivedTypeComposite) && item < 0) ? NEGATIVE_INTEGER\n                                        : 0)\n                                : ((FLOAT & derivedTypeComposite) && (item % 1) !== 0) ? (\n                                        ((POSITIVE_FLOAT & derivedTypeComposite) && item > 0) ? POSITIVE_FLOAT\n                                        : ((NEGATIVE_FLOAT & derivedTypeComposite) && item < 0) ? NEGATIVE_FLOAT\n                                        : 0)\n                                : 0)\n                        : ((INFINITE_NUMBER & derivedTypeComposite) && !isFinite(item)) ? (\n                                ((POSITIVE_INFINITY & derivedTypeComposite) && item > 0) ? POSITIVE_INFINITY\n                                : ((NEGATIVE_INFINITY & derivedTypeComposite) && item < 0) ? NEGATIVE_INFINITY\n                                : 0)\n                        : 0;\n                \n                case BOOLEAN:\n                        // Use non-strict equality to handle primitive and boxed booleans\n                    return ((TRUE & derivedTypeComposite) && (item == true)) ? TRUE             // jshint ignore:line\n                        : ((FALSE & derivedTypeComposite) && (item == false)) ? FALSE           // jshint ignore:line\n                        : 0;\n                \n                case ARRAY:\n                    return ((arrElemCount = item.length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_ARRAY & derivedTypeComposite) && arrElemCount === 0) ? EMPTY_ARRAY\n                        : ((SINGLE_ELEM_ARRAY & derivedTypeComposite) && arrElemCount === 1) ? SINGLE_ELEM_ARRAY\n                        : ((MULTI_ELEM_ARRAY & derivedTypeComposite) && arrElemCount > 1) ? MULTI_ELEM_ARRAY\n                        : 0;\n                \n                case OBJECT:\n                    return ((objPropCount = objKeys(item).length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_OBJECT & derivedTypeComposite) && objPropCount === 0) ? EMPTY_OBJECT\n                        : ((SINGLE_PROP_OBJECT & derivedTypeComposite) && objPropCount === 1) ? SINGLE_PROP_OBJECT\n                        : ((MULTI_PROP_OBJECT & derivedTypeComposite) && objPropCount > 1) ? MULTI_PROP_OBJECT\n                        : 0;\n            }\n            return 0;\n        }\n        \n        /**\n         * Gets the composite type consisting of the specified types.\n         */\n        function getCompositeType(types, item) {\n            var typeString;\n            \n            if (typeof types === 'string') {    // uncached string\n                typeString = types;\n                types = types.split(typeDelimiterRegExp);\n            } else if (!isArray(types)) {\n                types = [types];\n            }\n            \n            var compositeType = 0,\n                requestedType,\n                typeDefinition;\n            \n            for (var typeIndex = 0, typeCount = types.length; typeIndex < typeCount; typeIndex++) {\n                requestedType = types[typeIndex];\n                typeDefinition = (typeof requestedType === 'string') ? (aliasToTypeMapping[requestedType] || 0) \n                        : (typeof requestedType === 'object') ?         // Support for unregistered custom-validated type if validator function field present in obj\n                                (requestedType !== null && typeof requestedType.validator === 'function' ? requestedType : 0)\n                        : (requestedType || 0);\n                \n                if (typeof typeDefinition === 'number') {\n                    compositeType = (compositeType | (ANY_TYPE & typeDefinition));\n                } else if (typeof typeDefinition === 'function' && (item instanceof typeDefinition)) {\n                    return typeDefinition;\n                } else if (typeof typeDefinition === 'object' && typeDefinition.validator(item) === true) {     // No further need to null-check type definition\n                    return typeDefinition;\n                }\n            }\n            \n            if (compositeType && typeString && (typeListStringToTypeIdCacheSize <= MAX_REQUEST_TYPE_CACHE_SIZE)) {\n                typeListStringToTypeIdCache[typeString] = compositeType;\n                typeListStringToTypeIdCacheSize++;\n            }\n            return compositeType;\n        }\n        \n        /*\n         * ----------------\n         * HELPER FUNCTIONS\n         * ----------------\n         */\n\n        /**\n         * Builds an alias map using data in supplied value and alias mappings.\n         */\n        function buildAliasMappings() {\n            var typeAliasMapping = newObj(),\n                aliasTypeMapping = newObj(),\n                nameAliasMapping = newObj(),\n                usedAliases = newObj();\n            \n            objKeys(typeToValueMapping).forEach(function(typeName) {\n                var typeValue = typeToValueMapping[typeName];\n                var aliasName = (activeNameScheme ? activeNameScheme[typeName] : typeName);\n                aliasName = ((typeof aliasName === 'string' && aliasName.length > 0) ? aliasName : typeName);\n                \n                if (aliasName in usedAliases) {\n                    throwError('Type name conflict: \"' + aliasName + '\" is aliased to \"' + \n                            typeName + '\" and \"' + usedAliases[aliasName] + '\"');\n                }\n                if (typeof typeValue === 'number') {\n                    typeAliasMapping[typeValue] = aliasName;     // Type Ids used only for built-in simple and extended types (with numeric Ids) \n                }\n                aliasTypeMapping[aliasName] = typeValue;\n                nameAliasMapping[typeName] = aliasName;\n                \n                usedAliases[aliasName] = typeName;\n            });\n            typeToAliasMapping = typeAliasMapping;\n            aliasToTypeMapping = aliasTypeMapping;\n            nameToAliasMapping = nameAliasMapping;\n            \n            isAliasMode = !!activeNameScheme;\n            clearTypeListStringCache();\n        }\n        \n        function defineInterfacePackagesAndMethods(hostObj) {\n            hostObj.not = newObj();\n            hostObj.any = newObj();\n            hostObj.all = newObj();\n            hostObj.some = newObj();\n            hostObj.none = newObj();\n\n            hostObj.not.is = function(value, types) {\n                return !isType(value, types);\n            };\n\n            hostObj.any.is = getInterfaceFunction(isType, true, true, undefined, true);\n            hostObj.all.is = getInterfaceFunction(isType, true, undefined, true, false);\n            hostObj.some.is = getInterfaceFunction(isType, true, true, true, true);\n            hostObj.none.is = getInterfaceFunction(isType, true, true, undefined, false);\n        }\n        \n        /**\n         * Defines the typeId property and associated type check\n         * and interface methods for the specified type.\n         */\n        function defineType(typeName, typeDefinition, hostObj) {\n            if (typeName in typeToValueMapping) {\n                throwError('Cannot define type \\'' + typeName + '\\' - type already defined');\n            }\n\n            typeToValueMapping[typeName] = typeDefinition;\n            \n            if (typeof typeDefinition === 'number') {\n                Object.defineProperty(hostObj, typeName.toUpperCase(), {\n                    value: typeToValueMapping[typeName],\n                    enumerable: true,\n                    writable: false,\n                    configurable: false\n                });\n            }\n            \n            var typeMethodName = getTypeMethodName(typeName);\n            \n            var typeCheckFunction = function(item) {\n                return isType(item, (typeToValueMapping[typeName] || typeName));\n            };\n            \n            hostObj[typeMethodName] = typeCheckFunction;\n            \n            hostObj.not[typeMethodName] = function(value) {\n                return !typeCheckFunction(value);\n            };\n            \n            hostObj.any[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, true);\n            hostObj.all[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, undefined, true, false);\n            hostObj.some[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, true, true);\n            hostObj.none[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, false);\n        }\n        \n        /**\n         * Clears the memoization cache of type list strings used in requests.\n         */\n        function clearTypeListStringCache() {\n            typeListStringToTypeIdCache = newObj();\n            typeListStringToTypeIdCacheSize = 0;\n        }\n        \n        /**\n         * Gets the name to be used for the type-matching \n         * method name for the specified type.\n         */\n        function getTypeMethodName(typeName) { \n            var capitalizedTypeName = typeName.toLowerCase().replace(/(^|_)(.)/g, function(match, camelPrefix, camelChar) {\n                return camelChar.toUpperCase();\n            });\n            return 'is' + capitalizedTypeName;\n        }\n        \n        /**\n         * Creates an interface function using the specified parameters.\n         */\n        function getInterfaceFunction(delegateFunction, withTypes, trueCondition, falseCondition, terminationResult) {\n            return function(values, types) {\n                values = (!withTypes && arguments.length > 1 ? arraySlice.call(arguments)\n                        : isArray(values) ? values\n                        : [values]);\n    \n                var trueResult = false,\n                    falseResult = false,\n                    valueIndex;\n                \n                for (valueIndex = 0; valueIndex < values.length; valueIndex++) {\n                    if (delegateFunction(values[valueIndex], types)) {\n                        trueResult = true;\n                    } else {\n                        falseResult = true;\n                    }\n                    if ((trueCondition === undefined || trueResult === trueCondition) && \n                            (falseCondition === undefined || falseResult === falseCondition)) {\n                        return terminationResult;\n                    }\n                }\n                return !terminationResult;\n            };\n        }\n        \n        function capitalize(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        }\n\n        function throwError(message) {\n            throw new Error(LIB_NAME + ': ' + message);\n        }\n        \n        /*\n         * -----------------\n         * EXTENSIONS MODULE\n         * -----------------\n         */\n        \n        function registerNameScheme(schemeName, schemeAliases) {\n            if (typeof schemeName !== 'string' || schemeName.trim().length === 0 || typeof schemeAliases !== 'object') {\n                return;\n            }\n            var trimSchemeName = schemeName.trim(),\n                existingScheme = nameSchemes[trimSchemeName],\n                newScheme = newObj();\n            \n            objKeys(schemeAliases).forEach(function(typeName) {\n               newScheme[typeName] = schemeAliases[typeName];\n            });\n            \n            nameSchemes[trimSchemeName] = newScheme;\n            return existingScheme;\n        }\n        \n        extensionsModule.registerNameScheme = registerNameScheme;\n        \n        /*\n         * --------------\n         * OPTIONS MODULE\n         * --------------\n         */\n        \n        function setDelimiterPattern(delimiterPattern) {\n            delimiterPattern = ((delimiterPattern === null || delimiterPattern === undefined || delimiterPattern === '') ? \n                    TYPE_DELIMITER_DEFAULT_PATTERN : delimiterPattern);\n            \n            if (typeof delimiterPattern !== 'string') {\n                return;\n            }\n            delimiterPattern = ('[ ]*' + delimiterPattern + '[ ]*');\n            \n            if (typeDelimiterRegExp && (delimiterPattern === typeDelimiterRegExp.source)) {\n                return;\n            }\n            \n            typeDelimiterRegExp = new RegExp(delimiterPattern, 'g');\n            clearTypeListStringCache();\n        }\n        \n        function setNameScheme(nameScheme) {\n            if (nameScheme === undefined || nameScheme === null || nameScheme === NAME_SCHEME_DEFAULT_OPTION_VALUE) {\n                nameScheme = null;\n            }\n            else if (typeof nameScheme === 'string' && (nameScheme in nameSchemes)) {\n                nameScheme = nameSchemes[nameScheme];\n            }\n            if (nameScheme !== null && typeof nameScheme !== 'object') {\n                throwError('Unknown name scheme \"' + nameScheme + '\"');\n            }\n            activeNameScheme = nameScheme;\n            doRefresh();\n        }\n        \n        function setOptions(options) {\n            if (typeof options !== 'object') {\n                return;\n            }\n            objKeys(options).forEach(function(optionName) {\n                var optionMethod = optionsModule['set' + capitalize(optionName)];\n                \n                if (typeof optionMethod === 'function') {\n                    optionMethod(options[optionName]);\n                }\n            });\n        }\n        \n        optionsModule.setDelimiterPattern = setDelimiterPattern;\n        optionsModule.setNameScheme = setNameScheme;\n        optionsModule.set = setOptions;\n\n        /*\n         * --------------\n         * MODULE REFRESH\n         * --------------\n         */\n\n        function coreModuleRefreshHandler() {\n            buildAliasMappings();\n        }\n\n        function doRefresh() {\n            coreModuleRefreshHandler();\n            doModuleTriggeredRefresh(coreModuleRefreshHandler);\n        }\n        \n        var doModuleTriggeredRefresh = (function() {\n\n            var handlersRequestingModuleRefresh = [],\n                isModuleRefreshing = false,\n                isModuleRefreshRequested = false;\n\n            function refreshExtensions(requestingHandlers) {\n                moduleRefreshHandlers.forEach(function(handler) {\n                    /*\n                     * Don't invoke handlers belonging to extensions \n                     * that requested the current refresh.\n                     */\n                    if (requestingHandlers.indexOf(handler) < 0) {\n                        handler.call();\n                    }\n                });\n            }\n\n            /*\n             * Handles extensions' refresh requests by bunching all refresh \n             * requests made during an active refresh into a single subsequent\n             * refresh operation performed on completion of the active refresh.\n             * Also, when the subsequent refresh is processed, excludes handlers \n             * of all the extensions which requested the refresh, in order to \n             * prevent potential cyclic refresh loops in poorly implemented \n             * extensions which may trigger new refreshes while responding to \n             * refresh requests originated by themselves.\n             */\n            return function (requestingHandler) {\n                isModuleRefreshRequested = true;\n\n                if (requestingHandler) {\n                    handlersRequestingModuleRefresh.push(requestingHandler);\n                }\n                if (isModuleRefreshing) {\n                    return;\n                }\n\n                isModuleRefreshing = true;\n\n                while (isModuleRefreshRequested) {\n                    isModuleRefreshRequested = false;\n                    refreshExtensions(handlersRequestingModuleRefresh);\n                }\n\n                handlersRequestingModuleRefresh = [];\n                isModuleRefreshing = false;\n            };\n        })();\n\n        /*\n         * ----------------\n         * ADDON EXTENSIONS\n         * ----------------\n         */\n\n        function registerExtensions(extensions, xtypeModule) {\n            (isArray(extensions) ? extensions : [extensions]).forEach(function(extension) {\n                if (!extension || extension.type !== 'xtypejs' || typeof extension.init !== 'function') {\n                    throwError('Invalid extension - \"type\" property must be \"xtypejs\" and \"init\" property must be a function');\n                }\n                registeredExtensions.push(extension.init);\n                applyExtension(extension.init, xtypeModule);\n            });\n        }\n\n        function applyExtension(extensionInit, hostModule) {\n\n            var moduleRefreshHandler = null,\n\n                extensionInterface = {\n                \n                    getTypeDefinitions: function() {\n                        return typeToValueMapping;\n                    },\n\n                    getNameSchemes: function() {\n                        return nameSchemes;\n                    },\n                    \n                    getActiveNameScheme: function() {\n                        return activeNameScheme;\n                    },\n\n                    defineType: function(typeName, typeValue) {\n                        defineType(typeName, typeValue, hostModule);\n                    },\n\n                    refresh: function() {\n                        doModuleTriggeredRefresh(moduleRefreshHandler);\n                    },\n\n                    setRefreshHandler: function(handler) {\n                        var existingHandlerIndex = moduleRefreshHandlers.indexOf(moduleRefreshHandler || handler);\n\n                        if (existingHandlerIndex > -1) {\n                            moduleRefreshHandlers.splice(existingHandlerIndex, 1);\n                        }\n                        if (typeof handler === 'function') {\n                            moduleRefreshHandlers.push(handler);\n                            moduleRefreshHandler = handler;\n                        }\n                    }\n                };\n\n            extensionInit.call(extensionInterface, hostModule);\n        }\n        \n        /*\n         * ---------------------\n         * MODULE SETUP / EXPORT\n         * ---------------------\n         */\n        \n        function init() {\n            var moduleExport = xtype;\n\n            setDelimiterPattern(TYPE_DELIMITER_DEFAULT_PATTERN);\n            \n            ['Boolean', 'Number', 'String', 'Symbol', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error']\n            .forEach(function(objectType) {\n                objToStringToNameMapping['[object ' + objectType + ']'] = objectType.toLowerCase();\n            });\n            \n            defineInterfacePackagesAndMethods(moduleExport);\n            \n            objKeys(TYPE_VALUE_MAPPING).forEach(function(typeName) {\n                defineType(typeName, TYPE_VALUE_MAPPING[typeName], moduleExport);\n            });\n            \n            buildAliasMappings();\n            moduleRefreshHandlers.push(coreModuleRefreshHandler);\n            \n            Object.defineProperty(moduleExport, 'VERSION', {\n                value: (/\\s*{{[^}]*}}\\s*/g.test(LIB_VERSION) ? 'unspecified' : LIB_VERSION),\n                enumerable: true,\n                writable: false,\n                configurable: false\n            });\n            \n            /*\n             * Attach API methods to module export\n             */\n\n            moduleExport.type = type;\n            moduleExport.typeOf = typeOf;\n            moduleExport.which = which;\n            moduleExport.is = isType;\n            \n            moduleExport.ext = extensionsModule;\n            moduleExport.options = optionsModule;\n            \n            moduleExport.newInstance = newModuleInstance;\n\n            moduleExport.ext.registerExtension = function(extensions) {\n                extensions = (arguments.length > 1 ? arraySlice.call(arguments) : extensions);\n                registerExtensions(extensions, moduleExport);\n            };\n            \n            /*\n             * Apply registered extensions on new instance\n             */\n\n            registeredExtensions.forEach(function(extension) {\n                applyExtension(extension, moduleExport);\n            });\n            \n            return moduleExport;\n        }\n        \n        return init();\n    }\n    \n    \n    /*\n     * Export module\n     */\n    var moduleExport = newModuleInstance();\n    \n    \n    if (typeof define === 'function' && define.amd) {\n        define([], function() {\n            return moduleExport;\n        });\n    }\n    else if (typeof module === 'object' && module.exports) {\n        module.exports = moduleExport;\n    }\n    else {\n        moduleExport.noConflict = (function(previouslyDefinedValue) {\n            return function() {\n                root[LIB_NAME] = previouslyDefinedValue;\n                delete moduleExport.noConflict;\n                return moduleExport;\n            };\n        })(root[LIB_NAME]);\n        \n        root[LIB_NAME] = moduleExport;\n    }\n    \n})(this);"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}